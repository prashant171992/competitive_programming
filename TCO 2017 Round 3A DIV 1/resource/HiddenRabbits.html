<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>You are given an undirected tree with n nodes, labeled 0 through n-1.
For each valid i, there is an edge between nodes (i+1) and <b>p</b>[i].
There are <b>m</b> rabbits, numbered 0 through <b>m</b>-1.
Each of the rabbits wants to live in one of the nodes of the tree.
That node will be called its home.
Multiple rabbits may share the same home.
Your task is to choose the homes for all the rabbits according to some constraints.
<br></br>
<br></br>
You are given the int[] <b>p</b> and the int <b>m</b>.
You are also given four equally-long int[]s: <b>r</b>, <b>a</b>, <b>b</b>, and <b>x</b>.
These describe a set of constraints the homes of the rabbits have to satisfy.
<br></br>
<br></br>
Let h[j] denote the home of rabbit j.
For each valid i, we have the following constraint:
<ul>
<li>If we select <b>r</b>[i] to be the root of the tree, the least common ancestor of the nodes h[ <b>a</b>[i] ] and h[ <b>b</b>[i] ] must be the node <b>x</b>[i].</li>
</ul>

Please find and return a int[] h of length <b>m</b> that satisfies these constraints.
If there are multiple solutions, you may return any of them.
If there are no solutions, return an empty int[] instead.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>HiddenRabbits</td></tr><tr><td>Method:</td><td>whereAreTheRabbits</td></tr><tr><td>Parameters:</td><td>int[], int, int[], int[], int[], int[]</td></tr><tr><td>Returns:</td><td>int[]</td></tr><tr><td>Method signature:</td><td>int[] whereAreTheRabbits(int[] p, int m, int[] r, int[] a, int[] b, int[] x)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>p</b> will contain between 1 and 250 elements, inclusive. (It means that the number of nodes in the tree will be between 2 and 251, inclusive.)</td></tr><tr><td align="center" valign="top">-</td><td>For each i, 0 &lt;= <b>p</b>[i] &lt;= i.</td></tr><tr><td align="center" valign="top">-</td><td><b>m</b> will be between 2 and 250, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>r</b> will contain between 1 and 250 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>r</b>, <b>a</b>, <b>b</b>, <b>x</b> will contain the same number of elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>r</b>, <b>x</b> will be between 0 and |<b>p</b>|, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>a</b>, <b>b</b> will be between 0 and <b>m</b>-1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>For each i, <b>a</b>[i] != <b>b</b>[i].</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,2}</pre></td></tr><tr><td><pre>2</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{0}</pre></td></tr><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2">The tree looks like: 0 - 1 - 2 - 3.<br></br>
And we know that if we root the tree at node 2, then LCA(h[0], h[1]) = 1. That means one of them must be at node 1, and another one is at node 0 or node 1. We have 3 solutions: {0, 1}, {1, 0} and {1, 1}.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1}</pre></td></tr><tr><td><pre>2</pre></td></tr><tr><td><pre>{0,1}</pre></td></tr><tr><td><pre>{0,1}</pre></td></tr><tr><td><pre>{1,0}</pre></td></tr><tr><td><pre>{0,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {0, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2">We have: 
<ul>
<li>If we root the tree at node 0, then LCA is 0, that means one of them is at 0.</li>
<li>If we root the tree at node 1, then LCA is 1, that means one of them is at 1.</li>
</ul>
So there are 2 answers: {0, 1}, {1, 0}.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,1}</pre></td></tr><tr><td><pre>3</pre></td></tr><tr><td><pre>{0,0,0,2,3,2,3,2,3}</pre></td></tr><tr><td><pre>{0,1,2,0,0,1,1,2,2}</pre></td></tr><tr><td><pre>{1,2,0,1,1,2,2,0,0}</pre></td></tr><tr><td><pre>{1,1,1,2,3,2,3,2,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">From first 3 constraints we know: h[0], h[1], h[2] must be in node 2 or node 3.<br></br>
From next 2 constraints we know: Among {h[0], h[1]}, one of them is in node 2 and another is in node 3, that means h[0] != h[1].<br></br>
Next 2 constraints are similar, we have h[1] != h[2].<br></br>
And last 2 gives us h[2] != h[0].<br></br>
Then we have a contradiction: h[0], h[1], h[2] must be pairwise different but there are only 2 nodes to choose. So it is impossible
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,2}</pre></td></tr><tr><td><pre>4</pre></td></tr><tr><td><pre>{2,1,0,2,1,3}</pre></td></tr><tr><td><pre>{0,1,0,0,2,2}</pre></td></tr><tr><td><pre>{2,3,1,1,3,3}</pre></td></tr><tr><td><pre>{1,2,0,2,1,3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: {0, 2, 1, 3 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,0,0,1,0,2,3,1}</pre></td></tr><tr><td><pre>10</pre></td></tr><tr><td><pre>{3,3}</pre></td></tr><tr><td><pre>{2,6}</pre></td></tr><tr><td><pre>{6,2}</pre></td></tr><tr><td><pre>{5,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">LCA(h[2], h[6]) and LCA(h[6], h[2]) must be the same. So it is impossible.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,0,0,0,2,2,3,0,7,6,9,11,4,13,7,10,12,1,18}</pre></td></tr><tr><td><pre>15</pre></td></tr><tr><td><pre>{13,15,1,11,17,15,13,6,15,14,10,15,3,5,0,1,17,7,9,13,18,4,4,14,16}
</pre></td></tr><tr><td><pre>{2,0,13,12,5,11,14,10,12,7,7,2,14,9,14,0,0,3,0,6,13,3,1,6,14}
</pre></td></tr><tr><td><pre>{3,7,6,0,1,12,1,1,4,2,8,10,3,3,3,10,3,0,4,4,11,2,5,14,0}
</pre></td></tr><tr><td><pre>{0,7,0,7,18,0,1,0,0,7,10,7,0,2,0,0,7,7,7,0,0,0,18,0,0}
</pre></td></tr></table></td></tr><tr><td><pre>Returns: {7, 18, 7, 0, 0, 18, 0, 7, 10, 2, 0, 0, 0, 0, 1 }</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>